package com.als.hyobin;

import java.util.Scanner;

public class P006_수들의_합5 {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		
		int N = sc.nextInt();

		//i는 연속된 자연수의 개수이다. i가 1개면 N은 자기 자신의 합으로 나타낼 수 있다.
		//하지만 i가 2개부터는 판정이 필요하다. 먼저 연속된 자연수의 개수가 홀수인 경우를 생각해 보자. 즉 i가 홀수일 때이다.
		//숫자 N을 i로 나눠보자. n = N / i 이다. N이 i로 나누어 떨어질 경우, N / i 는 연속된 자연수에서 중간값이다.
		//예시를 들면, 6을 3으로 나누면, 2가 나오고 2는 1과 3사이의 중간값이다. 즉, n-1, n, n+1로 일반화할 수 있다.
		//연속된 자연수의 개수가 홀수이기 때문에 좌우의 -1, +1은 상쇄되고 n * i 로 나타낼 수 있다.
		//나누어 떨어지지 않는 경우, 예를 들면 7 / 3 = 2, -> 1 + 2 + 3 = 6이므로 일치하지 않는다.
		//하지만 나누어 떨어지는 경우에도 예외가 있다. 예를 들면 27을 9로 나누면 나누어 떨어지고 n은 3이 된다.
		//개수가 9개이고 3이 중간값이라면 ,  -1 0 1 2 3 4 5 6 7 이 되고 기존 공식이 성립하지 않는다.
		//따라서 왼쪽 마지막 값이 검사해 0 이하라면 성립하지 않고, 그 다음 순서도 마찬가지다. 따라서 반복문 탈출한다.
 		int count = 0;
		for (int i = 1; i <= N; i += 2) {
			int n = N / i;

			if (n - i / 2 <= 0)
				break;

			if (N % i == 0)
				count++;
		}
		
		
		//연속된 자연수의 개수가 짝수인 경우를 생각해 보자.
		//짝수로 나누어 떨어지는 경우에는 기본적으로 성립하지 않는다. 일단, 짝수로 나누어지는 수는 짝수뿐이다.
		//짝수로 나누어 떨어진다면 n은 정확히 N의 절반값이다. 즉 n / 2 인데, N / 2 + N / 2 + 1 은 N + 1이고 이를 4개 6개로 늘려도 항상 홀수가 된다.
		//따라서 N이 짝수로 나누어 떨어지는 경우를 제외하고 생각하자.
		//int 자료형에서 / 연산은 항상 나머지를 버린다. 따라서 아래와 같이 표현할 수 있다.
		//연속된 자연수의 개수가 2개이면 n, n+1이고 4개이면 n-1, n, n+1, n+2 이다. 즉 2n+1, 4n+2이다.
		//이를 일반화하면 i * n + i / 2로 표현할 수 있다.
		//위와 마찬가지로 왼쪽 마지막 값이 0 이하이면 성립하지 않으므로 탈출한다.
		for (int i = 2; i <= N; i += 2) {
			int n = N / i;

			if (n - i / 2 + 1 <= 0)
				break;

			if (i * n + i / 2 == N)
				count++;
		}
		
		//시간복잡도는 N이하의 횟수를 돌고 안에서는 상수 시간 연산을 하므로 O(N)으로 볼 수 있다.
		
		System.out.println(count);
		sc.close();
	}

}
